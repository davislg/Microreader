#include	<p24FJ64GB002.h>
#include 	<i2c.h>
#include "disp.h"



#define	idle_iic			IdleI2C2
#define	start_iic			StartI2C2
#define	master_write_iic	MasterWriteI2C2
#define	master_read_iic		MasterReadI2C2
#define	not_ack_iic			NotAckI2C2
#define	stop_iic			StopI2C2
#define	rstart_iic			RestartI2C2
#define	ack_iic				AckI2C2
#define	PEN_BIT				I2C2CONbits.PEN
#define	SEN_BIT				I2C2CONbits.SEN
#define	RSEN_BIT			I2C2CONbits.RSEN

const char font5x7[455] =
   {0x00, 0x00, 0x00, 0x00, 0x00 ,  // sp
    0x00, 0x00, 0x2f, 0x00, 0x00 ,  // !
    0x00, 0x07, 0x00, 0x07, 0x00 ,  // "
    0x14, 0x7f, 0x14, 0x7f, 0x14 ,  // #
    0x24, 0x2a, 0x7f, 0x2a, 0x12 ,  // $
    0xc4, 0xc8, 0x10, 0x26, 0x46 ,  // %
    0x36, 0x49, 0x55, 0x22, 0x50 ,  // &
    0x00, 0x05, 0x03, 0x00, 0x00 ,  // '
    0x00, 0x1c, 0x22, 0x41, 0x00 ,  // (
    0x00, 0x41, 0x22, 0x1c, 0x00 ,  // )
    0x14, 0x08, 0x3E, 0x08, 0x14 ,  // *
    0x08, 0x08, 0x3E, 0x08, 0x08 ,  // +
    0x00, 0x00, 0x50, 0x30, 0x00 ,  // ,
    0x10, 0x10, 0x10, 0x10, 0x10 ,  // -
    0x00, 0x60, 0x60, 0x00, 0x00 ,  // .
    0x20, 0x10, 0x08, 0x04, 0x02 ,  // /
    0x3E, 0x51, 0x49, 0x45, 0x3E ,  // 0
    0x00, 0x42, 0x7F, 0x40, 0x00 ,  // 1
    0x42, 0x61, 0x51, 0x49, 0x46 ,  // 2
    0x21, 0x41, 0x45, 0x4B, 0x31 ,  // 3
    0x18, 0x14, 0x12, 0x7F, 0x10 ,  // 4
    0x27, 0x45, 0x45, 0x45, 0x39 ,  // 5
    0x3C, 0x4A, 0x49, 0x49, 0x30 ,  // 6
    0x01, 0x71, 0x09, 0x05, 0x03 ,  // 7
    0x36, 0x49, 0x49, 0x49, 0x36 ,  // 8
    0x06, 0x49, 0x49, 0x29, 0x1E ,  // 9
    0x00, 0x36, 0x36, 0x00, 0x00 ,  // :
    0x00, 0x56, 0x36, 0x00, 0x00 ,  // ;
    0x08, 0x14, 0x22, 0x41, 0x00 ,  // <
    0x14, 0x14, 0x14, 0x14, 0x14 ,  // =
    0x00, 0x41, 0x22, 0x14, 0x08 ,  // >
    0x02, 0x01, 0x51, 0x09, 0x06 ,  // ?
    0x32, 0x49, 0x59, 0x51, 0x3E ,  // @
    0x7E, 0x11, 0x11, 0x11, 0x7E ,  // A
    0x7F, 0x49, 0x49, 0x49, 0x36 ,  // B
    0x3E, 0x41, 0x41, 0x41, 0x22 ,  // C
    0x7F, 0x41, 0x41, 0x22, 0x1C ,  // D
    0x7F, 0x49, 0x49, 0x49, 0x41 ,  // E
    0x7F, 0x09, 0x09, 0x09, 0x01 ,  // F
    0x3E, 0x41, 0x49, 0x49, 0x7A ,  // G
    0x7F, 0x08, 0x08, 0x08, 0x7F ,  // H
    0x00, 0x41, 0x7F, 0x41, 0x00 ,  // I
    0x20, 0x40, 0x41, 0x3F, 0x01 ,  // J
    0x7F, 0x08, 0x14, 0x22, 0x41 ,  // K
    0x7F, 0x40, 0x40, 0x40, 0x40 ,  // L
    0x7F, 0x02, 0x0C, 0x02, 0x7F ,  // M
    0x7F, 0x04, 0x08, 0x10, 0x7F ,  // N
    0x3E, 0x41, 0x41, 0x41, 0x3E ,  // O
    0x7F, 0x09, 0x09, 0x09, 0x06 ,  // P
    0x3E, 0x41, 0x51, 0x21, 0x5E ,  // Q
    0x7F, 0x09, 0x19, 0x29, 0x46 ,  // R
    0x46, 0x49, 0x49, 0x49, 0x31 ,  // S
    0x01, 0x01, 0x7F, 0x01, 0x01 ,  // T
    0x3F, 0x40, 0x40, 0x40, 0x3F ,  // U
    0x1F, 0x20, 0x40, 0x20, 0x1F ,  // V
    0x3F, 0x40, 0x38, 0x40, 0x3F ,  // W
    0x63, 0x14, 0x08, 0x14, 0x63 ,  // X
    0x07, 0x08, 0x70, 0x08, 0x07 ,  // Y
    0x61, 0x51, 0x49, 0x45, 0x43 ,  // Z
    0x00, 0x7F, 0x41, 0x41, 0x00 ,  // [
    0x55, 0x2A, 0x55, 0x2A, 0x55 ,  // 55
    0x00, 0x41, 0x41, 0x7F, 0x00 ,  // ]
    0x04, 0x02, 0x01, 0x02, 0x04 ,  // ^
    0x40, 0x40, 0x40, 0x40, 0x40 ,  // _
    0x00, 0x01, 0x02, 0x04, 0x00 ,  // '
    0x20, 0x54, 0x54, 0x54, 0x78 ,  // a
    0x7F, 0x48, 0x44, 0x44, 0x38 ,  // b
    0x38, 0x44, 0x44, 0x44, 0x20 ,  // c
    0x38, 0x44, 0x44, 0x48, 0x7F ,  // d
    0x38, 0x54, 0x54, 0x54, 0x18 ,  // e
    0x08, 0x7E, 0x09, 0x01, 0x02 ,  // f
    0x0C, 0x52, 0x52, 0x52, 0x3E ,  // g
    0x7F, 0x08, 0x04, 0x04, 0x78 ,  // h
    0x00, 0x44, 0x7D, 0x40, 0x00 ,  // i
    0x20, 0x40, 0x44, 0x3D, 0x00 ,  // j
    0x7F, 0x10, 0x28, 0x44, 0x00 ,  // k
    0x00, 0x41, 0x7F, 0x40, 0x00 ,  // l
    0x7C, 0x04, 0x18, 0x04, 0x78 ,  // m
    0x7C, 0x08, 0x04, 0x04, 0x78 ,  // n
    0x38, 0x44, 0x44, 0x44, 0x38 ,  // o
    0x7C, 0x14, 0x14, 0x14, 0x08 ,  // p
    0x08, 0x14, 0x14, 0x18, 0x7C ,  // q
    0x7C, 0x08, 0x04, 0x04, 0x08 ,  // r
    0x48, 0x54, 0x54, 0x54, 0x20 ,  // s
    0x04, 0x3F, 0x44, 0x40, 0x20 ,  // t
    0x3C, 0x40, 0x40, 0x20, 0x7C ,  // u
    0x1C, 0x20, 0x40, 0x20, 0x1C ,  // v
    0x3C, 0x40, 0x30, 0x40, 0x3C ,  // w
    0x44, 0x28, 0x10, 0x28, 0x44 ,  // x
    0x0C, 0x50, 0x50, 0x50, 0x3C ,  // y
    0x44, 0x64, 0x54, 0x4C, 0x44};  // z 
    
    

void shdn_disp (void)
{
lcd_cmd (0xAE);
}

void init_lcd (void)
{
/*
When RES# input is LOW, the chip is initialized with the following status:
1. Display is OFF
2. 128 x 39 Display Mode
3. Normal segment and display data column address and row address mapping (SEG0 mapped to
address 00h and COM0 mapped to address 00h)
4. Shift register data clear in serial interface
5. Display start line is set at display RAM address 0
6. Column address counter is set at 0
7. Normal scan direction of the COM outputs
8. Contrast control register is set at 7Fh
9. Normal display mode (Equivalent to A4h command)
*/
lcd_cmd (0xAE);//1
lcd_cmd (0xA1);//3
lcd_cmd (0xA4);//9
lcd_cmd (0x40);
lcd_cmd (0xC0);
lcd_cmd (0x00);
lcd_cmd (0x10);
lcd_cmd (0xAF);
clrscr(0x00);
}

void refresh_lcd (unsigned char * buff)
{
disp_set_xy(0,0);
putslcd2(buff+ROW0);
disp_set_xy(0,1);
putslcd2(buff+ROW1);
disp_set_xy(0,2);
putslcd2(buff+ROW2);
disp_set_xy(0,3);
putslcd2(buff+ROW3);
}

void putslcd2(char *data)
{
unsigned int counter;
counter=0;
iic_start();
iic_write(0x78);
iic_write(0x40);
while(counter<DISP_COLS)
	{  
  	char_print2(*data);
	*data++;
	counter++;
  	}
iic_stop();
}

void char_print2 (unsigned char data)
{
unsigned char underline;
unsigned int	disp_loop_var;
unsigned int temp;

if (data&0x80) underline = 1;
	else underline = 0;
data = data&0x7F;
if (data<' ') data = ' ';
temp = ((unsigned int)(data - 0x20)*5);
for (disp_loop_var=0;disp_loop_var<5;disp_loop_var++)
	{
	if (underline==1)	iic_write ((font5x7[temp+disp_loop_var])^0xFF) ;	
	else 				iic_write(font5x7[temp+disp_loop_var]);	
	}
if (underline==1)
	iic_write(0xFF);	
else
	iic_write(0x00);	
}


void putslcd(char *data)
{
unsigned int counter;
	counter=0;
		while(counter<DISP_COLS)
//		while((*data != '\0')&(counter<DISP_COLS))
  			{  
		  	char_print(*data);
			*data++;
			counter++;
		  	}
}

void char_print (unsigned char data)
{
unsigned char underline;
unsigned int	disp_loop_var;
unsigned int temp;
iic_start();
iic_write(0x78);
iic_write(0x40);
if (data&0x80) underline = 1;
	else underline = 0;
data = data&0x7F;
if (data<' ') data = ' ';
temp = ((unsigned int)(data - 0x20)*5);
for (disp_loop_var=0;disp_loop_var<5;disp_loop_var++)
	{
	if (underline==1)	iic_write ((font5x7[temp+disp_loop_var])^0xFF) ;	
	else 				iic_write(font5x7[temp+disp_loop_var]);	
	}
if (underline==1)
	iic_write(0xFF);	
else
	iic_write(0x00);	
iic_stop();

}


void clrscr (unsigned char data)
{
unsigned char x,y;
for (y=0;y<4;y++)
	{
	disp_set_xy(0,y);
	iic_start();
	iic_write(0x78);
	iic_write(0x40);
	for (x=0;x<96;x++)
		iic_write(data);
	iic_stop();
	}
}

void disp_set_xy (unsigned char x, unsigned char y)
{
if (y>3) return;
if (x>95) return;
lcd_cmd (0xB0+y);
lcd_cmd (0x00 + (x&0x0F));
lcd_cmd (0x10 + ((x>>4)&0x0F));
}
void lcd_cmd(unsigned char data)
{
iic_start();
iic_write(0x78);
iic_write(0x80);
iic_write(data);
iic_stop();
}

void iic_start (void)
{
 	idle_iic();
  	start_iic();
	while(SEN_BIT);
}

void iic_stop (void)
{
 	idle_iic();
	stop_iic();
	  /* Wait till stop sequence is completed */
	while(PEN_BIT);
}

void iic_write (unsigned char data)
{
 	idle_iic();
	master_write_iic(data);
}
